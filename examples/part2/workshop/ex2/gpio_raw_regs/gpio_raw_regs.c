/**
  ******************************************************************************
  * \file    gpio_raw_regs.c
  * \author  Александр Смирнов
  * \version 1.0.1
  * \date    25.02.2023
  * \brief   Программа на языке C для учебного стенда на базе
  *          STM32F072RBT6 в среде разработки Keil uVision 5.
  *          Подключение библиотек поддержки МК STM32F072RBT6 осуществляется
  *          средствами IDE Keil через менеджер пакетов Run-Time Environment (RTE).
  *          Программа включает светодиод D1.
  *          Программа работает в режиме 0 учебного стенда (S1 = 0, S2 = 0).
  ******************************************************************************
  */

/* В этой программе используется обращение к регистра специальных функций
   по абсолютным адресам вместо библиотеки CMSIS. */


/* Для обращения к периферийным модулям по абсолютным адресам в языке C
   необходимо освоить очень важный элемент языка - указатели.
   По сути указатели это те же самые адреса в терминологии языка C. С помощью указателей можно
   производить адресную арифметику (из базового адреса вычислять другие адреса) и обращаться к любым
   областям памяти в адресном пространстве.
   Рассмотрим в начале простой пример:
   *((int *)(0x4000)) = 1;
   В этом примере через в 32-х разрядную ячейку памяти по адресу 0x4000 записывается 1.
   Это выражение *((int *)(0x4000)) состоит из числа 0x4000 - адреса регистра в шестнадцатиричном формате.
   Компилятору C нужно показать, что 0x4000 это не просто число, а адрес.
   Делается это с помощью операции приведение типов:
   (int *)(0x4000) - здесь символ * показывает то, что это указатель, а не число. Ключевое
   слово int то, что по этому адресу лежит целочисленное число со знаком.
   Чтобы обратиться по адресу мы должны заключить его в скобки с символом * в начале - *(pointer).
   Это операция в C называется разыменованием.
   В нашем примере это будет *((int *)(0x4000)).
   Теперь чтобы записать единицу по адресу 0x4000 можно написать так:
   *((int *)(0x4000)) = 1;
   Но чтобы не писать постоянно эту конструкцию можно использовать директиву define:
   #define REG *((int *)(0x4000))
   И дальнейшем пользоваться более удобной записью:
   REG = 1;
   В приведенном ниже примере есть небольшие отличия в объявлении адреса и приведении типа:
   #define RCC_AHBENR      (*((volatile unsigned int *)(0x40021000 + 0x14)))
   Во-первых, (0x40021000 + 0x14) - это адрес базового регистра модуля (RCC) + смещение конкретного
   регистра (AHBENR) относительно базового. Каждый периферийный модуль имеет несколько регистров.
   Все они располагаются друг за другом начиная с какого-то базового адреса. В техническом описании адреса
   регистров приводятся именно так - базовый адрес + смещение.
   Во-вторых, в приведение типов (volatile unsigned int *) добавлены два ключевых слова.
   unsigned - указывает на то, что число по адресу беззнакового типа. И действительно знак (самый
   старший бит) во всех регистрах управления периферийными модулями не имеет смысла.
   Использование знаковой переменной при обращении к регистрам может создавать потенциальные ошибки
   со старшим битом.
   volatile - указывает компилятору на то, что каждый раз когда в коде будет производится чтение
   по данному адресу необходимо именно читать эту ячейку, а не использовать копию из регистра центрального
   процессора. Современные компиляторы стараются оптимизировать программы и снизить количество
   обращений к памяти, так как эти операции медленные по сравнению с операциями на внутренних регистрах
   центрального процессора. Поэтому они пытаются создавать когда это возможно
   копии переменных во внутренних регистрах центрального процессора. Но периферийные модули работают
   независимо от центрального процессора и соответственно содержимое регистров изменяется независимо.
   Если будет использоваться копия, то невозможны такие операции как проверка флага в цикле,
   потому что всегда будет проверяться старое значение регистра.
   Так так язык С это высокоуровневый язык, то конструкции языка для обращения к регистрам
   на первый взгляд перегружены и трудновоспринимаемы. Но это только в начале знакомства с языком.
   После получения определённого опыта работы с указателями эти конструкции будут казаться элементарными. */

/*
   Любая запись в регистр специальных функций изменяет содержимого всего регистра.
   Если необходимо измение состояние только одного бита необходимо использовать следующий алгоритм:
   1. Прочитать содержимого регистра
   2. Внести изменения изменения в копию содержимого регистра с помощью логических операций и масок
   3. Записать новое значение обратно в регистр

   Для установки бита:
   reg = reg | 0x08;
   или
   reg = reg | (1 << 3);
   или
   reg |= (1 << 3);

   Для сброса бита:
   reg = reg & 0xF7;
   или
   reg = reg & ~0x08;
   или
   reg = reg & ~(1 << 3);
   или
   reg &= ~(1 << 3);
*/

/* Обращение к регистру разрешения тактирования
   AHB peripheral clock enable register (RCC_AHBENR) через указатель */
#define RCC_AHBENR      (*((volatile unsigned int *)(0x40021000 + 0x14)))

/* Обращение к регистру режима порта C
   GPIO port mode register (MODER) через указатель */
#define GPIOC_MODER     (*((volatile unsigned int *)(0x48000800 + 0x00)))

/* Обращение к регистру выходных данных порта C
   GPIO port output data register (ODR) через указатель */
#define GPIOC_ODR       (*((volatile unsigned int *)(0x48000800 + 0x14)))

/* Функция main - точка входа в программу.
   Если опустить детали, то именно с этой функции начинается работа
   программы после ее запуска. В случае встраиваемой системы именно
   она начинает исполняться после выхода МК из состояния сброса.
   Функция с таким названием должна быть только одна на весь проект. */
int main(void)
{
    /* Инициализация периферийных модулей.
       Перед началом использования любого периферийного модуля его необходимо
       инициализировать, то есть настроить.
       После сброса МК все периферийные модули как правило выключены.
       Режимы альтернативных функций отключены и все линии МК подключены к
       портам ввода/вывода общего назначения (GPIO).
       При этом сам порт настроен на ввод. */

      /* Включение тактирования модулей.
       Практически все современные МК имеют возможность управлять тактированием
       каждого модуля. При выключенном тактировании модуль не потребляет
       электроэнергию. После сброса МК тактирование отключено практически
       у всех модулей, в том числе и у порта ввода вывода.
       В строчке кода ниже производится включение тактирования порта А.
       Для включения тактирования порта A необходимо в регистре
       AHB peripheral clock enable register (RCC_AHBENR) записать 1
       в позицию 19 (в девятнадцатый бит IOPCEN).
       В начале читается состояние регистра (RCC_AHBENR), затем
       с помощью операции побитового ИЛИ (оператор | в языке  С) устанавливается
       в 1 бит номер 19 (число 0x00080000 - в этом числе 1 в 19 бите), и результат
       записывается вновь в регистр RCC_AHBENR.
       */
    RCC_AHBENR = RCC_AHBENR | 0x00080000;

    /* Настройка на вывод линии PC0 (D1).
       Порты по сбросу настроены на ввод.
       Согласно Reference Manual для перевода линии PC0 в режим вывода
       (Push/Pull) необходимо установить бит 0 в 1 в регистре
       GPIO port mode register (MODER).
       Установка осуществляется с помощью маски 0x00000001 (все нули кроме
       нулевого бита) и операции побитового ИЛИ (оператор |). */
    GPIOC_MODER = GPIOC_MODER | 0x00000001;

    /* Включить светодиод PC0 (D1).
       Согласно Reference manual для управления портом вывода необходимо
       осуществлять запись в регистр GPIO port output data register (ODR).
       При этом 0 - низкий активный уровень (Vss), 1 - высокий (Vdd) на
       выходе соответствующей линии порта.
       Согласно функциональной схеме, чтобы включить светодиод нужно
       подключить его анод к питанию (Vdd), то есть записать в PC0 значение 1.
       Установка осуществляется с помощью маски 0x00000001 (все нули кроме
       нулевого бита) и операции побитового ИЛИ (оператор |). */
    GPIOC_ODR = GPIOC_ODR | 0x00000001;

    /* Бесконечный цикл.
       Программа на языке C для ПК с операционной системой (ОС) может не иметь
       бесконечного цикла в конце. После завершения работы программы для ПК
       управление возвращается ОС и центральный процессор ПК начинает
       вычислять другие программы. В программе для МК возвращать управление
       некуда. Если не установить эту заглушку, МК начнет исполнять команды
       находящиеся в памяти за программой. В лучшем случаем это будет пустая
       память (заполненная 0xFF или 0x00), в худшем случае обрывки другой
       программы, которая была ранее загружена в МК и которая была больше
       этой программы. Если МК "провалится" туда, то поведение системы будет
       непредсказуемым.
       В языке ассемблера ARM также применялась похожая конструкция:
       STOP    B STOP
       Полным аналогом на языке C является:
       for(;;); или while(1);
    */
    while (1)
    {
    }
}
